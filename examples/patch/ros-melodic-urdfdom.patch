diff --git a/CMakeLists.txt b/CMakeLists.txt
index 92762f1..3d51785 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -67,7 +67,7 @@ else()
 endif()
 
 set(PKG_NAME ${PROJECT_NAME})
-set(PKG_LIBRARIES urdfdom_sensor urdfdom_model_state urdfdom_model urdfdom_world)
+set(PKG_LIBRARIES urdfdom_model urdfdom_world)
 set(PKG_DEPENDS urdfdom_headers console_bridge)
 set(cmake_conf_file "cmake/urdfdom-config.cmake")
 configure_file("${CMAKE_CURRENT_SOURCE_DIR}/${cmake_conf_file}.in" "${CMAKE_BINARY_DIR}/${cmake_conf_file}" @ONLY)
@@ -78,7 +78,7 @@ install(FILES ${CMAKE_BINARY_DIR}/${cmake_conf_file}
 if (NOT MSVC)
   set(PKG_DESC "Unified Robot Description Format")
   set(PKG_DEPENDS "urdfdom_headers console_bridge") # make the list separated by spaces instead of ;
-  set(PKG_URDF_LIBS "-lurdfdom_sensor -lurdfdom_model_state -lurdfdom_model -lurdfdom_world")
+  set(PKG_URDF_LIBS "-lurdfdom_model -lurdfdom_world")
   set(pkg_conf_file "cmake/pkgconfig/urdfdom.pc")
   configure_file("${CMAKE_CURRENT_SOURCE_DIR}/${pkg_conf_file}.in" "${CMAKE_BINARY_DIR}/${pkg_conf_file}" @ONLY)
   install(FILES ${CMAKE_BINARY_DIR}/${pkg_conf_file}
diff --git a/urdf_parser/CMakeLists.txt b/urdf_parser/CMakeLists.txt
index 3952064..662a1ee 100644
--- a/urdf_parser/CMakeLists.txt
+++ b/urdf_parser/CMakeLists.txt
@@ -8,14 +8,6 @@ add_library(urdfdom_model SHARED src/pose.cpp src/model.cpp src/link.cpp src/joi
 target_link_libraries(urdfdom_model ${TinyXML_LIBRARIES} ${console_bridge_LIBRARIES})
 set_target_properties(urdfdom_model PROPERTIES SOVERSION ${URDF_MAJOR_MINOR_VERSION})
 
-add_library(urdfdom_sensor SHARED src/urdf_sensor.cpp)
-target_link_libraries(urdfdom_sensor urdfdom_model ${TinyXML_LIBRARIES} ${console_bridge_LIBRARIES})
-set_target_properties(urdfdom_sensor PROPERTIES SOVERSION ${URDF_MAJOR_MINOR_VERSION})
-
-add_library(urdfdom_model_state SHARED src/urdf_model_state.cpp src/twist.cpp)
-target_link_libraries(urdfdom_model_state ${TinyXML_LIBRARIES} ${console_bridge_LIBRARIES})
-set_target_properties(urdfdom_model_state PROPERTIES SOVERSION ${URDF_MAJOR_MINOR_VERSION})
-
 # --------------------------------
 
 add_executable(check_urdf src/check_urdf.cpp)
@@ -37,6 +29,4 @@ INSTALL(TARGETS urdfdom_model DESTINATION ${CMAKE_INSTALL_LIBDIR})
 INSTALL(TARGETS urdfdom_world DESTINATION ${CMAKE_INSTALL_LIBDIR})
 INSTALL(TARGETS check_urdf urdf_to_graphiz urdf_mem_test
   DESTINATION ${CMAKE_INSTALL_BINDIR})
-INSTALL(TARGETS urdfdom_sensor DESTINATION ${CMAKE_INSTALL_LIBDIR})
-INSTALL(TARGETS urdfdom_model_state DESTINATION ${CMAKE_INSTALL_LIBDIR})
 INSTALL(DIRECTORY include/urdf_parser DESTINATION ${CMAKE_INSTALL_INCLUDEDIR})
diff --git a/urdf_parser/src/urdf_model_state.cpp b/urdf_parser/src/urdf_model_state.cpp
deleted file mode 100644
index aaaca76..0000000
--- a/urdf_parser/src/urdf_model_state.cpp
+++ /dev/null
@@ -1,153 +0,0 @@
-/*********************************************************************
-* Software License Agreement (BSD License)
-* 
-*  Copyright (c) 2008, Willow Garage, Inc.
-*  All rights reserved.
-* 
-*  Redistribution and use in source and binary forms, with or without
-*  modification, are permitted provided that the following conditions
-*  are met:
-* 
-*   * Redistributions of source code must retain the above copyright
-*     notice, this list of conditions and the following disclaimer.
-*   * Redistributions in binary form must reproduce the above
-*     copyright notice, this list of conditions and the following
-*     disclaimer in the documentation and/or other materials provided
-*     with the distribution.
-*   * Neither the name of the Willow Garage nor the names of its
-*     contributors may be used to endorse or promote products derived
-*     from this software without specific prior written permission.
-* 
-*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-*  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-*  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
-*  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
-*  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
-*  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
-*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-*  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
-*  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
-*  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
-*  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
-*  POSSIBILITY OF SUCH DAMAGE.
-*********************************************************************/
-
-/* Author: John Hsu */
-
-
-#include <urdf_model_state/model_state.h>
-#include <urdf_model/utils.h>
-#include <fstream>
-#include <locale>
-#include <sstream>
-#include <stdexcept>
-#include <string>
-#include <algorithm>
-#include <tinyxml.h>
-#include <console_bridge/console.h>
-
-namespace urdf{
-
-bool parseModelState(ModelState &ms, TiXmlElement* config)
-{
-  ms.clear();
-
-  const char *name_char = config->Attribute("name");
-  if (!name_char)
-  {
-    CONSOLE_BRIDGE_logError("No name given for the model_state.");
-    return false;
-  }
-  ms.name = std::string(name_char);
-
-  const char *time_stamp_char = config->Attribute("time_stamp");
-  if (time_stamp_char)
-  {
-    try {
-      ms.time_stamp.set(strToDouble(time_stamp_char));
-    } catch(std::runtime_error &) {
-      CONSOLE_BRIDGE_logError("Parsing time stamp [%s] failed", time_stamp_char);
-      return false;
-    }
-  }
-
-  TiXmlElement *joint_state_elem = config->FirstChildElement("joint_state");
-  if (joint_state_elem)
-  {
-    JointStateSharedPtr joint_state;
-    joint_state.reset(new JointState());
-
-    const char *joint_char = joint_state_elem->Attribute("joint");
-    if (joint_char)
-      joint_state->joint = std::string(joint_char);
-    else
-    {
-      CONSOLE_BRIDGE_logError("No joint name given for the model_state.");
-      return false;
-    }
-    
-    // parse position
-    const char *position_char = joint_state_elem->Attribute("position");
-    if (position_char)
-    {
-
-      std::vector<std::string> pieces;
-      urdf::split_string( pieces, position_char, " ");
-      for (unsigned int i = 0; i < pieces.size(); ++i){
-        if (pieces[i] != ""){
-          try {
-            joint_state->position.push_back(strToDouble(pieces[i].c_str()));
-          } catch(std::runtime_error &) {
-            throw ParseError("position element ("+ pieces[i] +") is not a valid float");
-          }
-        }
-      }
-    }
-
-    // parse velocity
-    const char *velocity_char = joint_state_elem->Attribute("velocity");
-    if (velocity_char)
-    {
-
-      std::vector<std::string> pieces;
-      urdf::split_string( pieces, velocity_char, " ");
-      for (unsigned int i = 0; i < pieces.size(); ++i){
-        if (pieces[i] != ""){
-          try {
-            joint_state->velocity.push_back(strToDouble(pieces[i].c_str()));
-          } catch(std::runtime_error &) {
-            throw ParseError("velocity element ("+ pieces[i] +") is not a valid float");
-          }
-        }
-      }
-    }
-
-    // parse effort
-    const char *effort_char = joint_state_elem->Attribute("effort");
-    if (effort_char)
-    {
-
-      std::vector<std::string> pieces;
-      urdf::split_string( pieces, effort_char, " ");
-      for (unsigned int i = 0; i < pieces.size(); ++i){
-        if (pieces[i] != ""){
-          try {
-            joint_state->effort.push_back(strToDouble(pieces[i].c_str()));
-          } catch(std::runtime_error &) {
-            throw ParseError("effort element ("+ pieces[i] +") is not a valid float");
-          }
-        }
-      }
-    }
-
-    // add to vector
-    ms.joint_states.push_back(joint_state);
-  }
-  return false;
-}
-
-
-
-}
-
-
diff --git a/urdf_parser/src/urdf_sensor.cpp b/urdf_parser/src/urdf_sensor.cpp
deleted file mode 100644
index 29626f4..0000000
--- a/urdf_parser/src/urdf_sensor.cpp
+++ /dev/null
@@ -1,360 +0,0 @@
-/*********************************************************************
-* Software License Agreement (BSD License)
-* 
-*  Copyright (c) 2008, Willow Garage, Inc.
-*  All rights reserved.
-* 
-*  Redistribution and use in source and binary forms, with or without
-*  modification, are permitted provided that the following conditions
-*  are met:
-* 
-*   * Redistributions of source code must retain the above copyright
-*     notice, this list of conditions and the following disclaimer.
-*   * Redistributions in binary form must reproduce the above
-*     copyright notice, this list of conditions and the following
-*     disclaimer in the documentation and/or other materials provided
-*     with the distribution.
-*   * Neither the name of the Willow Garage nor the names of its
-*     contributors may be used to endorse or promote products derived
-*     from this software without specific prior written permission.
-* 
-*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-*  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-*  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
-*  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
-*  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
-*  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
-*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-*  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
-*  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
-*  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
-*  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
-*  POSSIBILITY OF SUCH DAMAGE.
-*********************************************************************/
-
-/* Author: John Hsu */
-
-
-#include <urdf_sensor/sensor.h>
-#include <fstream>
-#include <locale>
-#include <sstream>
-#include <stdexcept>
-#include <string>
-#include <algorithm>
-#include <tinyxml.h>
-#include <console_bridge/console.h>
-
-namespace urdf{
-
-bool parsePose(Pose &pose, TiXmlElement* xml);
-
-bool parseCamera(Camera &camera, TiXmlElement* config)
-{
-  camera.clear();
-  camera.type = VisualSensor::CAMERA;
-
-  TiXmlElement *image = config->FirstChildElement("image");
-  if (image)
-  {
-    const char* width_char = image->Attribute("width");
-    if (width_char)
-    {
-      try
-      {
-        camera.width = std::stoul(width_char);
-      }
-      catch (std::invalid_argument &e)
-      {
-        CONSOLE_BRIDGE_logError("Camera image width [%s] is not a valid int: %s", width_char, e.what());
-        return false;
-      }
-      catch (std::out_of_range &e)
-      {
-        CONSOLE_BRIDGE_logError("Camera image width [%s] is out of range: %s", width_char, e.what());
-        return false;
-      }
-    }
-    else
-    {
-      CONSOLE_BRIDGE_logError("Camera sensor needs an image width attribute");
-      return false;
-    }
-
-    const char* height_char = image->Attribute("height");
-    if (height_char)
-    {
-      try
-      {
-        camera.height = std::stoul(height_char);
-      }
-      catch (std::invalid_argument &e)
-      {
-        CONSOLE_BRIDGE_logError("Camera image height [%s] is not a valid int: %s", height_char, e.what());
-        return false;
-      }
-      catch (std::out_of_range &e)
-      {
-        CONSOLE_BRIDGE_logError("Camera image height [%s] is out of range: %s", height_char, e.what());
-        return false;
-      }
-    }
-    else
-    {
-      CONSOLE_BRIDGE_logError("Camera sensor needs an image height attribute");
-      return false;
-    }
-
-    const char* format_char = image->Attribute("format");
-    if (format_char)
-      camera.format = std::string(format_char);
-    else
-    {
-      CONSOLE_BRIDGE_logError("Camera sensor needs an image format attribute");
-      return false;
-    }    
-
-    const char* hfov_char = image->Attribute("hfov");
-    if (hfov_char)
-    {
-      try {
-        camera.hfov = strToDouble(hfov_char);
-      } catch(std::runtime_error &) {
-        CONSOLE_BRIDGE_logError("Camera image hfov [%s] is not a valid float", hfov_char);
-        return false;
-      }
-    }
-    else
-    {
-      CONSOLE_BRIDGE_logError("Camera sensor needs an image hfov attribute");
-      return false;
-    }
-
-    const char* near_char = image->Attribute("near");
-    if (near_char)
-    {
-      try {
-        camera.near = strToDouble(near_char);
-      } catch(std::runtime_error &) {
-        CONSOLE_BRIDGE_logError("Camera image near [%s] is not a valid float", near_char);
-        return false;
-      }
-    }
-    else
-    {
-      CONSOLE_BRIDGE_logError("Camera sensor needs an image near attribute");
-      return false;
-    }
-
-    const char* far_char = image->Attribute("far");
-    if (far_char)
-    {
-      try {
-        camera.far = strToDouble(far_char);
-      } catch(std::runtime_error &) {
-        CONSOLE_BRIDGE_logError("Camera image far [%s] is not a valid float", far_char);
-        return false;
-      }
-    }
-    else
-    {
-      CONSOLE_BRIDGE_logError("Camera sensor needs an image far attribute");
-      return false;
-    }
-    
-  }
-  else
-  {
-    CONSOLE_BRIDGE_logError("Camera sensor has no <image> element");
-    return false;
-  }
-  return true;
-}
-
-bool parseRay(Ray &ray, TiXmlElement* config)
-{
-  ray.clear();
-  ray.type = VisualSensor::RAY;
-
-  TiXmlElement *horizontal = config->FirstChildElement("horizontal");
-  if (horizontal)
-  {
-    const char* samples_char = horizontal->Attribute("samples");
-    if (samples_char)
-    {
-      try
-      {
-        ray.horizontal_samples = std::stoul(samples_char);
-      }
-      catch (std::invalid_argument &e)
-      {
-        CONSOLE_BRIDGE_logError("Ray horizontal samples [%s] is not a valid float: %s", samples_char, e.what());
-        return false;
-      }
-      catch (std::out_of_range &e)
-      {
-        CONSOLE_BRIDGE_logError("Ray horizontal samples [%s] is out of range: %s", samples_char, e.what());
-        return false;
-      }
-    }
-
-    const char* resolution_char = horizontal->Attribute("resolution");
-    if (resolution_char)
-    {
-      try {
-        ray.horizontal_resolution = strToDouble(resolution_char);
-      } catch(std::runtime_error &) {
-        CONSOLE_BRIDGE_logError("Ray horizontal resolution [%s] is not a valid float", resolution_char);
-        return false;
-      }
-    }
-
-    const char* min_angle_char = horizontal->Attribute("min_angle");
-    if (min_angle_char)
-    {
-      try {
-        ray.horizontal_min_angle = strToDouble(min_angle_char);
-      } catch(std::runtime_error &) {
-        CONSOLE_BRIDGE_logError("Ray horizontal min_angle [%s] is not a valid float", min_angle_char);
-        return false;
-      }
-    }
-
-    const char* max_angle_char = horizontal->Attribute("max_angle");
-    if (max_angle_char)
-    {
-      try {
-        ray.horizontal_max_angle = strToDouble(max_angle_char);
-      } catch(std::runtime_error &) {
-        CONSOLE_BRIDGE_logError("Ray horizontal max_angle [%s] is not a valid float", max_angle_char);
-        return false;
-      }
-    }
-  }
-  
-  TiXmlElement *vertical = config->FirstChildElement("vertical");
-  if (vertical)
-  {
-    const char* samples_char = vertical->Attribute("samples");
-    if (samples_char)
-    {
-      try
-      {
-        ray.vertical_samples = std::stoul(samples_char);
-      }
-      catch (std::invalid_argument &e)
-      {
-        CONSOLE_BRIDGE_logError("Ray vertical samples [%s] is not a valid float: %s", samples_char, e.what());
-        return false;
-      }
-      catch (std::out_of_range &e)
-      {
-        CONSOLE_BRIDGE_logError("Ray vertical samples [%s] is out of range: %s", samples_char, e.what());
-        return false;
-      }
-    }
-
-    const char* resolution_char = vertical->Attribute("resolution");
-    if (resolution_char)
-    {
-      try {
-        ray.vertical_resolution = strToDouble(resolution_char);
-      } catch(std::runtime_error &) {
-        CONSOLE_BRIDGE_logError("Ray vertical resolution [%s] is not a valid float", resolution_char);
-        return false;
-      }
-    }
-
-    const char* min_angle_char = vertical->Attribute("min_angle");
-    if (min_angle_char)
-    {
-      try {
-        ray.vertical_min_angle = strToDouble(min_angle_char);
-      } catch(std::runtime_error &) {
-        CONSOLE_BRIDGE_logError("Ray vertical min_angle [%s] is not a valid float", min_angle_char);
-        return false;
-      }
-    }
-
-    const char* max_angle_char = vertical->Attribute("max_angle");
-    if (max_angle_char)
-    {
-      try {
-        ray.vertical_max_angle = strToDouble(max_angle_char);
-      } catch(std::runtime_error &) {
-        CONSOLE_BRIDGE_logError("Ray vertical max_angle [%s] is not a valid float", max_angle_char);
-        return false;
-      }
-    }
-  }
-  return false;
-}
-
-VisualSensorSharedPtr parseVisualSensor(TiXmlElement *g)
-{
-  VisualSensorSharedPtr visual_sensor;
-
-  // get sensor type
-  TiXmlElement *sensor_xml;
-  if (g->FirstChildElement("camera"))
-  {
-    Camera *camera = new Camera();
-    visual_sensor.reset(camera);
-    sensor_xml = g->FirstChildElement("camera");
-    if (!parseCamera(*camera, sensor_xml))
-      visual_sensor.reset();
-  }
-  else if (g->FirstChildElement("ray"))
-  {
-    Ray *ray = new Ray();
-    visual_sensor.reset(ray);
-    sensor_xml = g->FirstChildElement("ray");
-    if (!parseRay(*ray, sensor_xml))
-      visual_sensor.reset();
-  }
-  else
-  {
-    CONSOLE_BRIDGE_logError("No know sensor types [camera|ray] defined in <sensor> block");
-  }
-  return visual_sensor;
-}
-
-
-bool parseSensor(Sensor &sensor, TiXmlElement* config)
-{
-  sensor.clear();
-
-  const char *name_char = config->Attribute("name");
-  if (!name_char)
-  {
-    CONSOLE_BRIDGE_logError("No name given for the sensor.");
-    return false;
-  }
-  sensor.name = std::string(name_char);
-
-  // parse parent_link_name
-  const char *parent_link_name_char = config->Attribute("parent_link_name");
-  if (!parent_link_name_char)
-  {
-    CONSOLE_BRIDGE_logError("No parent_link_name given for the sensor.");
-    return false;
-  }
-  sensor.parent_link_name = std::string(parent_link_name_char);
-
-  // parse origin
-  TiXmlElement *o = config->FirstChildElement("origin");
-  if (o)
-  {
-    if (!parsePose(sensor.origin, o))
-      return false;
-  }
-
-  // parse sensor
-  sensor.sensor = parseVisualSensor(config);
-  return true;
-}
-
-
-}
-
-
